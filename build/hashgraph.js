// Generated by CoffeeScript 1.10.0
(function() {
  var Visualizer, delay, draw, eventWidth, height, machineHeight, makeMachine, names, paddingLeft, topOffset, width;

  Visualizer = {
    machines: []
  };

  Visualizer.addMachine = function(node) {
    return Visualizer.machines.push(node);
  };

  Visualizer.sendMessage = function(fromMachine, toMachine, message, duration) {
    var fromX, fromY, messageCircle, onArrive, toX, toY;
    if (duration == null) {
      duration = 1000 + Math.random() * 2000;
    }
    onArrive = function() {
      console.log('woot');
      toMachine.receiveMessage(message);
      return messageCircle.remove();
    };
    toX = toMachine.position.left;
    toY = toMachine.position.top;
    fromX = fromMachine.position.left;
    fromY = fromMachine.position.top;
    messageCircle = Visualizer.circle(fromX, fromY, 15);
    messageCircle.animate({
      transform: ["T", toX - fromX, toY - fromY]
    }, duration);
    delay(duration, onArrive);
    return console.log(fromMachine.name, '->', toMachine.name);
  };

  makeMachine = function(name) {
    var events, gossip, knownMachines, machine, receiveMessage;
    machine = {};
    knownMachines = [];
    events = [];
    gossip = function() {
      var receiver;
      if (knownMachines.length === 1) {
        return alert("Dont know any machines. Cant gossip");
      }
      while (!(receiver && receiver.name !== name)) {
        receiver = knownMachines[Math.floor(Math.random() * knownMachines.length)];
      }
      return Visualizer.sendMessage(machine, receiver, 'hello');
    };
    receiveMessage = function() {
      return console.log(name, ' received gossip ');
    };
    Object.assign(machine, {
      name: name,
      gossip: gossip,
      receiveMessage: receiveMessage,
      events: events,
      knownMachines: knownMachines
    });
    events.push({
      node: machine,
      hash: Math.random()
    });
    return machine;
  };

  height = 800;

  machineHeight = 220;

  width = 600;

  eventWidth = 30;

  topOffset = 20;

  paddingLeft = 150;

  draw = function() {
    var circle, event, eventIndex, eventX, i, index, j, len, len1, machine, machineAngle, machineIndex, machineWidth, machineX, machineY, node, path, rect, ref, ref1, results, text, timelineStartY;
    Visualizer.clear();
    ref = Visualizer.machines;
    results = [];
    for (machineIndex = i = 0, len = ref.length; i < len; machineIndex = ++i) {
      machine = ref[machineIndex];
      machineAngle = machineIndex * 2 * Math.PI / Visualizer.machines.length;
      machineWidth = machine.knownMachines.length * eventWidth + eventWidth;
      machineX = (1 + Math.cos(-machineAngle - Math.PI)) * width / 2 - eventWidth - machineWidth / 2 + paddingLeft;
      machineY = (1 + Math.sin(-machineAngle)) * (height - machineHeight) / 2;
      machine.position = {
        left: machineX,
        top: machineY
      };
      machine.dimensions = {
        width: machineWidth,
        height: machineHeight
      };
      rect = Visualizer.rect(machineX, machineY + topOffset, machineWidth, machineHeight);
      rect.attr({
        stroke: '#ccc',
        fill: '#fafafa'
      });
      text = Visualizer.text(machineX + machineWidth / 2, machineY + 8, machine.name);
      timelineStartY = machineY + machineHeight - 20;
      ref1 = machine.knownMachines;
      for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
        node = ref1[index];
        path = Visualizer.path("M " + (machineX + eventWidth + index * eventWidth) + "," + timelineStartY + " l 0," + (-machineHeight + topOffset + 20));
        path.attr({
          stroke: '#333'
        });
        text = Visualizer.text(machineX + eventWidth + index * eventWidth, machineY + machineHeight, node.name);
      }
      results.push((function() {
        var k, len2, ref2, results1;
        ref2 = machine.events;
        results1 = [];
        for (eventIndex = k = 0, len2 = ref2.length; k < len2; eventIndex = ++k) {
          event = ref2[eventIndex];
          eventX = machineX + eventWidth + machine.knownMachines.indexOf(event.node) * eventWidth;
          circle = Visualizer.circle(eventX, timelineStartY, 10);
          circle.attr("fill", "#EEE");
          results1.push(circle.attr("stroke", "#333"));
        }
        return results1;
      })());
    }
    return results;
  };

  names = ['Alice', 'Bob', 'Charly', 'Dan', 'Eve', 'Fred', 'Gus', 'Henry', 'Ivy', 'Jim'];

  $(function() {
    Visualizer.__proto__ = Raphael(document.getElementById('hashgraph_visualizer'));
    $('button#add_node').click(function() {
      var i, len, machine, name, newMachine, ref;
      name = names[Visualizer.machines.length];
      newMachine = makeMachine(name);
      Visualizer.addMachine(newMachine);
      ref = Visualizer.machines;
      for (i = 0, len = ref.length; i < len; i++) {
        machine = ref[i];
        newMachine.knownMachines.push(machine);
      }
      draw();
      return $("<button>Make " + name + " gossip</button>").appendTo($('#gossips')).click(newMachine.gossip);
    });
    $('button#add_node').click();
    return $('button#add_node').click();
  });

  delay = function(t, fn) {
    return setTimeout(fn, t);
  };

}).call(this);
